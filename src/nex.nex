include "std/std.nex"

const OpType.push       0 end
const OpType.intrinsic  1 end
const OpType.if         2 end
const OpType.else       3 end
const OpType.while      4 end
const OpType.do         5 end
const OpType.end        6 end

const Op 40 end // u64 u64 ptr u32 u32
fun Op.type     ptr -- ptr ->  0 + end // u64
fun Op.value    ptr -- ptr ->  8 + end // u64
fun Op.filepath ptr -- ptr -> 16 + end // ptr
fun Op.line     ptr -- ptr -> 24 + end // u64
fun Op.col      ptr -- ptr -> 32 + end // u64

const Intrinsic.plus         0 end
const Intrinsic.minus        1 end
const Intrinsic.mul          2 end
const Intrinsic.divmod       3 end
const Intrinsic.dump         4 end
const Intrinsic.eq           5 end
const Intrinsic.gt           6 end
const Intrinsic.lt           7 end
const Intrinsic.ge           8 end
const Intrinsic.le           9 end
const Intrinsic.ne          10 end
const Intrinsic.and         11 end
const Intrinsic.or          12 end
const Intrinsic.dup         13 end
const Intrinsic.over        14 end
const Intrinsic.swap        15 end
const Intrinsic.drop        16 end
const Intrinsic.rot         17 end
const Intrinsic.syscall0    18 end
const Intrinsic.syscall1    19 end
const Intrinsic.syscall2    20 end
const Intrinsic.syscall3    21 end
const Intrinsic.syscall4    22 end
const Intrinsic.syscall5    23 end
const Intrinsic.syscall6    24 end

const OP_CAP 1024 end
alloc OpBuf Op OP_CAP * end
alloc OpCount u64 end
0 OpCount s64

fun PushOp int int ptr int int ->
    OpCount r64 Op * OpBuf +
    dup Op.col      rot swap s64
    dup Op.line     rot swap s64
    dup Op.filepath rot swap s64
    dup Op.value    rot swap s64
    dup Op.type     rot swap s64
    drop
    OpCount inc64
end

fun PrintOps ->
    0 while dup OpCount r64 < do
        dup Op * OpBuf +
        over printd
        "->" print
        dup Op.filepath r64 cast_ptr print
        ":" print
        dup Op.line  r64 printd
        ":" print
        dup Op.col   r64 printd
        ": type: " print
        dup Op.type  r64 printd
        " data: " print
        dup Op.value r64 printd
        "\n" print
        drop

        1 +
    end drop
end

fun CmdEcho ptr ->
    alloc status u64 end
    alloc empty pointer end
    0 empty s64

    "[CMD]" print
    dup while dup r64 0 != do
        " " print
        // TODO escape the logged cmd
        dup r64 cast_ptr print
        8 +
    end drop
    "\n" print

    fork

    dup 0 = if
        drop
        dup r64 cast_ptr empty
        rot rot
        execve
        dup 0 < if
            "ERROR: could not execute external program\n" eprint
            1 exit
        end cast_ptr
    else 
        dup 0 > if
            drop
            NULL cast_ptr 0 status 0 1 - wait4 drop
        else
            drop
            "ERROR: could not fork a child\n" eprint
            1 exit
        end
    end

    drop
end

fun GenerateAssembly ->
    alloc out u64 end
    
    420                            // mode
    O_CREAT O_WRONLY or O_TRUNC or // flags
    "output.asm"                   // path
    AT_FDCWD
    openat
    out s64

    out r64 0 < if
        "ERROR: could not open 'output.asm'\n" eprint
        1 exit
    end

    "segment .text\n"                           out r64 fprint
    "dump:\n"                                   out r64 fprint
    "    mov     r9, -3689348814741910323\n"    out r64 fprint
    "    sub     rsp, 40\n"                     out r64 fprint
    "    mov     BYTE [rsp+31], 10\n"           out r64 fprint
    "    lea     rcx, [rsp+30]\n"               out r64 fprint
    ".L2:\n"                                    out r64 fprint
    "    mov     rax, rdi\n"                    out r64 fprint
    "    lea     r8, [rsp+32]\n"                out r64 fprint
    "    mul     r9\n"                          out r64 fprint
    "    mov     rax, rdi\n"                    out r64 fprint
    "    sub     r8, rcx\n"                     out r64 fprint
    "    shr     rdx, 3\n"                      out r64 fprint
    "    lea     rsi, [rdx+rdx*4]\n"            out r64 fprint
    "    add     rsi, rsi\n"                    out r64 fprint
    "    sub     rax, rsi\n"                    out r64 fprint
    "    add     eax, 48\n"                     out r64 fprint
    "    mov     BYTE [rcx], al\n"              out r64 fprint
    "    mov     rax, rdi\n"                    out r64 fprint
    "    mov     rdi, rdx\n"                    out r64 fprint
    "    mov     rdx, rcx\n"                    out r64 fprint
    "    sub     rcx, 1\n"                      out r64 fprint
    "    cmp     rax, 9\n"                      out r64 fprint
    "    ja      .L2\n"                         out r64 fprint
    "    lea     rax, [rsp+32]\n"               out r64 fprint
    "    mov     edi, 1\n"                      out r64 fprint
    "    sub     rdx, rax\n"                    out r64 fprint
    "    xor     eax, eax\n"                    out r64 fprint
    "    lea     rsi, [rsp+32+rdx]\n"           out r64 fprint
    "    mov     rdx, r8\n"                     out r64 fprint
    "    mov     rax, 1\n"                      out r64 fprint
    "    syscall\n"                             out r64 fprint
    "    add     rsp, 40\n"                     out r64 fprint
    "    ret\n"                                 out r64 fprint
    "global _start\n"                           out r64 fprint
    "_start:\n"                                 out r64 fprint
    0 while dup OpCount r64 < do
        
        "addr_" out r64 fprint
        dup out r64 fprintd
        ":\n" out r64 fprint

        dup Op * OpBuf +

        dup Op.type r64 OpType.push = if
            "    mov rax, "                 out r64 fprint dup Op.value r64 out r64 fprintd "\n" out r64 fprint
            "    push rax\n"                out r64 fprint
        orelse dup Op.type r64 OpType.if = if
            "    pop rax\n"                 out r64 fprint
            "    test rax, rax\n"           out r64 fprint
            "    jz addr_"                  out r64 fprint dup Op.value r64 out r64 fprintd "\n" out r64 fprint
        orelse dup Op.type r64 OpType.else = if
            "    jmp addr_"                 out r64 fprint dup Op.value r64 out r64 fprintd "\n" out r64 fprint
        orelse dup Op.type r64 OpType.while = if
            // while
        orelse dup Op.type r64 OpType.do = if
            "    pop rax\n"                 out r64 fprint
            "    test rax, rax\n"           out r64 fprint
            "    jz addr_"                  out r64 fprint dup Op.value r64 out r64 fprintd "\n" out r64 fprint
        orelse dup Op.type r64 OpType.end = if
            over 1 + over Op.value r64 != if
                "    jmp addr_"                 out r64 fprint dup Op.value r64 out r64 fprintd "\n" out r64 fprint
            end
        orelse dup Op.type r64 OpType.intrinsic = if
            dup Op.value r64 Intrinsic.plus = if
                "    pop rax\n"                 out r64 fprint
                "    pop rbx\n"                 out r64 fprint
                "    add rax, rbx\n"            out r64 fprint
                "    push rax\n"                out r64 fprint
            orelse dup Op.value r64 Intrinsic.minus = if
                "    pop rax\n"                 out r64 fprint
                "    pop rbx\n"                 out r64 fprint
                "    sub rbx, rax\n"            out r64 fprint
                "    push rbx\n"                out r64 fprint
            orelse dup Op.value r64 Intrinsic.mul = if
                "    pop rax\n"                 out r64 fprint
                "    pop rbx\n"                 out r64 fprint
                "    mul rbx\n"                 out r64 fprint
                "    push rax\n"                out r64 fprint
            orelse dup Op.value r64 Intrinsic.divmod = if
                "    xor rdx, rdx\n"            out r64 fprint
                "    pop rbx\n"                 out r64 fprint
                "    pop rax\n"                 out r64 fprint
                "    div rbx\n"                 out r64 fprint
                "    push rax\n"                out r64 fprint
                "    push rdx\n"                out r64 fprint
            orelse dup Op.value r64 Intrinsic.dump = if
                "    pop rdi\n"                 out r64 fprint
                "    call dump\n"               out r64 fprint
            orelse dup Op.value r64 Intrinsic.eq = if
                "    mov rcx, 0\n"              out r64 fprint
                "    mov rdx, 1\n"              out r64 fprint
                "    pop rax\n"                 out r64 fprint
                "    pop rbx\n"                 out r64 fprint
                "    cmp rax, rbx\n"            out r64 fprint
                "    cmove rcx, rdx\n"          out r64 fprint
                "    push rcx\n"                out r64 fprint
            orelse dup Op.value r64 Intrinsic.gt = if
                "    mov rcx, 0\n"              out r64 fprint
                "    mov rdx, 1\n"              out r64 fprint
                "    pop rbx\n"                 out r64 fprint
                "    pop rax\n"                 out r64 fprint
                "    cmp rax, rbx\n"            out r64 fprint
                "    cmovg rcx, rdx\n"          out r64 fprint
                "    push rcx\n"                out r64 fprint
            orelse dup Op.value r64 Intrinsic.lt = if
                "    mov rcx, 0\n"              out r64 fprint
                "    mov rdx, 1\n"              out r64 fprint
                "    pop rbx\n"                 out r64 fprint
                "    pop rax\n"                 out r64 fprint
                "    cmp rax, rbx\n"            out r64 fprint
                "    cmovl rcx, rdx\n"          out r64 fprint
                "    push rcx\n"                out r64 fprint
            orelse dup Op.value r64 Intrinsic.ge = if
                "    mov rcx, 0\n"              out r64 fprint
                "    mov rdx, 1\n"              out r64 fprint
                "    pop rbx\n"                 out r64 fprint
                "    pop rax\n"                 out r64 fprint
                "    cmp rax, rbx\n"            out r64 fprint
                "    cmovge rcx, rdx\n"         out r64 fprint
                "    push rcx\n"                out r64 fprint
            orelse dup Op.value r64 Intrinsic.le = if
                "    mov rcx, 0\n"              out r64 fprint
                "    mov rdx, 1\n"              out r64 fprint
                "    pop rbx\n"                 out r64 fprint
                "    pop rax\n"                 out r64 fprint
                "    cmp rax, rbx\n"            out r64 fprint
                "    cmovle rcx, rdx\n"         out r64 fprint
                "    push rcx\n"                out r64 fprint
            orelse dup Op.value r64 Intrinsic.le = if
                "    mov rcx, 0\n"              out r64 fprint
                "    mov rdx, 1\n"              out r64 fprint
                "    pop rbx\n"                 out r64 fprint
                "    pop rax\n"                 out r64 fprint
                "    cmp rax, rbx\n"            out r64 fprint
                "    cmovne rcx, rdx\n"         out r64 fprint
                "    push rcx\n"                out r64 fprint
            orelse dup Op.value r64 Intrinsic.and = if
                "    pop rbx\n"                 out r64 fprint
                "    pop rax\n"                 out r64 fprint
                "    and rbx, rax\n"            out r64 fprint
                "    push rbx\n"                out r64 fprint
            orelse dup Op.value r64 Intrinsic.or = if
                "    pop rbx\n"                 out r64 fprint
                "    pop rax\n"                 out r64 fprint
                "    or rbx, rax\n"             out r64 fprint
                "    push rbx\n"                out r64 fprint
            orelse dup Op.value r64 Intrinsic.dup = if
                "    pop rax\n"                 out r64 fprint
                "    push rax\n"                out r64 fprint
                "    push rax\n"                out r64 fprint
            orelse dup Op.value r64 Intrinsic.over = if
                "    pop rax\n"                 out r64 fprint
                "    pop rbx\n"                 out r64 fprint
                "    push rbx\n"                out r64 fprint
                "    push rax\n"                out r64 fprint
                "    push rbx\n"                out r64 fprint
            orelse dup Op.value r64 Intrinsic.swap = if
                "    pop rax\n"                 out r64 fprint
                "    pop rbx\n"                 out r64 fprint
                "    push rax\n"                out r64 fprint
                "    push rbx\n"                out r64 fprint
            orelse dup Op.value r64 Intrinsic.drop = if
                "    pop rax\n"                 out r64 fprint
            orelse dup Op.value r64 Intrinsic.rot = if
                "    pop rax\n"                 out r64 fprint
                "    pop rbx\n"                 out r64 fprint
                "    pop rcx\n"                 out r64 fprint
                "    push rbx\n"                out r64 fprint
                "    push rax\n"                out r64 fprint
                "    push rcx\n"                out r64 fprint
            orelse dup Op.value r64 Intrinsic.syscall0 = if
                "    pop rax\n"                 out r64 fprint
                "    syscall\n"                 out r64 fprint
                "    push rax\n"                out r64 fprint
            orelse dup Op.value r64 Intrinsic.syscall1 = if
                "    pop rax\n"                 out r64 fprint
                "    pop rdi\n"                 out r64 fprint
                "    syscall\n"                 out r64 fprint
                "    push rax\n"                out r64 fprint
            orelse dup Op.value r64 Intrinsic.syscall2 = if
                "    pop rax\n"                 out r64 fprint
                "    pop rdi\n"                 out r64 fprint
                "    pop rsi\n"                 out r64 fprint
                "    syscall\n"                 out r64 fprint
                "    push rax\n"                out r64 fprint
            orelse dup Op.value r64 Intrinsic.syscall3 = if
                "    pop rax\n"                 out r64 fprint
                "    pop rdi\n"                 out r64 fprint
                "    pop rsi\n"                 out r64 fprint
                "    pop rdx\n"                 out r64 fprint
                "    syscall\n"                 out r64 fprint
                "    push rax\n"                out r64 fprint
            orelse dup Op.value r64 Intrinsic.syscall4 = if
                "    pop rax\n"                 out r64 fprint
                "    pop rdi\n"                 out r64 fprint
                "    pop rsi\n"                 out r64 fprint
                "    pop rdx\n"                 out r64 fprint
                "    pop r10\n"                 out r64 fprint
                "    syscall\n"                 out r64 fprint
                "    push rax\n"                out r64 fprint
            orelse dup Op.value r64 Intrinsic.syscall5 = if
                "    pop rax\n"                 out r64 fprint
                "    pop rdi\n"                 out r64 fprint
                "    pop rsi\n"                 out r64 fprint
                "    pop rdx\n"                 out r64 fprint
                "    pop r10\n"                 out r64 fprint
                "    pop r8\n"                  out r64 fprint
                "    syscall\n"                 out r64 fprint
                "    push rax\n"                out r64 fprint
            orelse dup Op.value r64 Intrinsic.syscall6 = if
                "    pop rax\n"                 out r64 fprint
                "    pop rdi\n"                 out r64 fprint
                "    pop rsi\n"                 out r64 fprint
                "    pop rdx\n"                 out r64 fprint
                "    pop r10\n"                 out r64 fprint
                "    pop r8\n"                  out r64 fprint
                "    pop r9\n"                  out r64 fprint
                "    syscall\n"                 out r64 fprint
                "    push rax\n"                out r64 fprint
            else
                "ERROR: unreachable intrinsic\n" eprint
                1 exit
            end
        else
            "ERROR: unreachable op\n" eprint
            1 exit
        end

        drop

        1 +
    end drop

    "addr_" out r64 fprint
    OpCount r64 out r64 fprintd
    ":\n" out r64 fprint

    "    mov rax, 60\n" out r64 fprint
    "    mov rdi, 0\n" out r64 fprint
    "    syscall\n" out r64 fprint

    alloc nasmArgv pointer 4 * end
    "/usr/bin/nasm"     nasmArgv 0 pointer * + s64
    "-felf64"           nasmArgv 1 pointer * + s64
    "output.asm"        nasmArgv 2 pointer * + s64
    0                   nasmArgv 3 pointer * + s64
    nasmArgv CmdEcho

    alloc ldArgv pointer 5 * end
    "/usr/bin/ld"       ldArgv 0 pointer * + s64
    "-o"                ldArgv 1 pointer * + s64
    "output"            ldArgv 2 pointer * + s64
    "output.o"          ldArgv 3 pointer * + s64
    NULL                ldArgv 4 pointer * + s64
    ldArgv CmdEcho

    alloc outputArgv pointer 2 * end
    "./output"          outputArgv 0 pointer * + s64
    NULL                outputArgv 1 pointer * + s64
    outputArgv CmdEcho
end

const Lexer 40 end
fun Lexer.content ptr -- ptr ->   0 + end // ptr
fun Lexer.file    ptr -- ptr ->   8 + end // ptr
fun Lexer.line    ptr -- ptr ->  16 + end // u64
fun Lexer.col     ptr -- ptr ->  24 + end // u64
fun Lexer.ccol    ptr -- ptr ->  32 + end // u64

fun Lexer.Construct ptr ptr ptr -> // file content lexer
    1 over Lexer.line s64
    1 over Lexer.ccol s64
    dup Lexer.content rot swap s64
    dup Lexer.file    rot swap s64
    drop
end

fun Lexer.NextLine ptr ->
    while
        dup Lexer.content r64 cast_ptr r8
        dup 10 != // 10: ascii code for \n
        swap 0 !=
        and
    do
        dup Lexer.content inc64
    end

    dup Lexer.content r64 cast_ptr r8 10 = if
        dup Lexer.content inc64 
        dup Lexer.line inc64
        1 over Lexer.ccol s64
    end

    drop
end

fun Lexer.NextToken ptr ptr -- bool -> // buf Lexer -- TokenType
    alloc buf pointer end
    swap buf s64

    while
        dup Lexer.content r64 // index before trim
        over Lexer.content StrTrimLeft
        over Lexer.content r64 // index after trim
        swap - over Lexer.ccol r64 +
        over Lexer.ccol s64
        dup Lexer.content r64 cast_ptr r8 0 = if
            false
        else
            dup Lexer.content r64 cast_ptr r8 10 = // 10: ascii code for \n
        end
    do
        dup Lexer.NextLine
    end

    dup Lexer.content r64 cast_ptr r8 0 = if
        drop false
    else
        dup Lexer.ccol r64 over Lexer.col s64

        while dup Lexer.content r64 cast_ptr r8 dup IsSpace lnot swap 0 != and do
            dup Lexer.content r64 cast_ptr r8 buf r64 cast_ptr s8
            dup Lexer.content inc64
            buf inc64
            dup Lexer.ccol inc64
        end

        drop true
    end
end

fun Lexer.Loc ptr -- ptr int int -> // file line col
    dup Lexer.file r64 cast_ptr
    swap
    dup Lexer.line r64
    swap
    dup Lexer.col  r64
    swap drop
end

fun Lexer.PrintLoc ptr ->
    dup Lexer.file r64 cast_ptr print
    ":" print
    dup Lexer.line r64 printd
    ":" print
    dup Lexer.col  r64 printd
    ":" print
    drop
end

const PARSE_BLOCK_STACK_CAP 1024 end
alloc ParseBlockStack PARSE_BLOCK_STACK_CAP end
alloc ParseBlockStackCount u64 end
0 ParseBlockStack s64

fun ParseBlockStackPush int ->
    ParseBlockStackCount r64 PARSE_BLOCK_STACK_CAP >= if
        "ERROR: parse block stack overflow\n" eprint
        1 exit
    end

    ParseBlockStackCount r64 u64 * ParseBlockStack +
    s64
    ParseBlockStackCount inc64
end

fun ParseBlockStackPop -- int ->
    ParseBlockStackCount r64 0 <= if
        "ERROR: parse block stack underflow\n" eprint
        1 exit
    end

    ParseBlockStackCount dec64
    ParseBlockStackCount r64 u64 * ParseBlockStack +
    r64
end

fun ParseFile ptr ->
    alloc filepath string end
    filepath s64

    0
    O_RDONLY
    filepath r64 cast_ptr
    AT_FDCWD
    openat

    dup 0 < if
        "could not open file '" eprint filepath r64 cast_ptr eprint "'\n" eprint
        1 exit
    end

    alloc fd u64 end
    fd s64
    alloc statbuf stat end
    statbuf fd r64 fstat 0 < if
        "could not determine size of file '" eprint filepath r64 cast_ptr eprint "'\n" eprint
        1 exit
    end

    alloc content pointer end
    alloc contentLength u64 end
    statbuf stat.st_size r64 contentLength s64
    

    0                        // offset
    fd r64                   // fd
    MAP_PRIVATE              // flags
    PROT_READ                // prot
    contentLength r64        // length
    NULL cast_ptr            // addr
    mmap
    content s64

    content r64 0 < if
        "ERROR: could not map file " eprint filepath r64 cast_ptr eprint "'\n" eprint
        1 exit
    end

    alloc buf 256 end
    alloc lexer Lexer end
    filepath r64 cast_ptr content r64 cast_ptr lexer Lexer.Construct
    
    while
        0 buf 256 memset
        buf lexer Lexer.NextToken
    do
        // buf is already null-terminated because of the previous 'memset'
        
        // -- KEYWORDS --------------------
        buf "if" streq if
            OpCount r64 ParseBlockStackPush
            OpType.if 0 lexer Lexer.Loc PushOp
        orelse buf "else" streq if
            ParseBlockStackCount r64 0 = if
                lexer Lexer.PrintLoc

                ": ERROR: 'else' can only be used in 'if' blocks\n" print

                1 exit
            end

            ParseBlockStackPop
            OpBuf over Op * +

            dup Op.type r64 OpType.if != if
                lexer Lexer.PrintLoc

                ": ERROR: 'else' can only be used in 'if' blocks\n" print

                1 exit
            end

            OpCount r64 1 + swap Op.value s64
            drop

            OpCount r64 ParseBlockStackPush

            OpType.else 0 lexer Lexer.Loc PushOp
        orelse buf "while" streq if
            OpCount r64 ParseBlockStackPush
            OpType.while 0 lexer Lexer.Loc PushOp
        orelse buf "do" streq if
            ParseBlockStackCount r64 0 = if
                lexer Lexer.PrintLoc

                ": ERROR: 'do' can only be used in 'while' blocks\n" print

                1 exit
            end

            ParseBlockStackPop
            OpBuf over Op * +

            dup Op.type r64 OpType.while != if
                lexer Lexer.PrintLoc

                ": ERROR: 'do' can only be used in 'while' blocks\n" print

                1 exit
            end

            drop

            OpCount r64 ParseBlockStackPush

            OpType.do swap lexer Lexer.Loc PushOp
        orelse buf "end" streq if
            ParseBlockStackCount r64 0 = if
                lexer Lexer.PrintLoc

                ": ERROR: 'end' can only close 'if', 'if-else' and 'while-do' blocks\n" print

                1 exit
            end

            ParseBlockStackPop
            OpBuf over Op * +

            dup  Op.type r64 OpType.if   =
            over Op.type r64 OpType.else = or if
                OpCount r64 over Op.value s64

                OpType.end OpCount r64 1 + lexer Lexer.Loc PushOp
            orelse dup Op.type r64 OpType.do = if
                OpType.end over Op.value r64 lexer Lexer.Loc PushOp

                OpCount r64 over Op.value s64
            else
                lexer Lexer.PrintLoc

                ": ERROR: 'end' can only close 'if', 'if-else' and 'while-do' blocks\n" print

                1 exit
            end

            drop drop


        // -- INTRINSICS ------------------
        orelse buf "+" streq if
            OpType.intrinsic Intrinsic.plus     lexer Lexer.Loc PushOp
        orelse buf "-" streq if
            OpType.intrinsic Intrinsic.minus    lexer Lexer.Loc PushOp
        orelse buf "*" streq if
            OpType.intrinsic Intrinsic.mul      lexer Lexer.Loc PushOp
        orelse buf "divmod" streq if
            OpType.intrinsic Intrinsic.divmod   lexer Lexer.Loc PushOp
        orelse buf "dump" streq if
            OpType.intrinsic Intrinsic.dump     lexer Lexer.Loc PushOp
        orelse buf "=" streq if
            OpType.intrinsic Intrinsic.eq       lexer Lexer.Loc PushOp
        orelse buf ">" streq if
            OpType.intrinsic Intrinsic.gt       lexer Lexer.Loc PushOp
        orelse buf "<" streq if
            OpType.intrinsic Intrinsic.lt       lexer Lexer.Loc PushOp
        orelse buf ">=" streq if
            OpType.intrinsic Intrinsic.ge       lexer Lexer.Loc PushOp
        orelse buf "<=" streq if
            OpType.intrinsic Intrinsic.le       lexer Lexer.Loc PushOp
        orelse buf "!=" streq if
            OpType.intrinsic Intrinsic.ne       lexer Lexer.Loc PushOp
        orelse buf "and" streq if
            OpType.intrinsic Intrinsic.and      lexer Lexer.Loc PushOp
        orelse buf "or" streq if
            OpType.intrinsic Intrinsic.or       lexer Lexer.Loc PushOp
        orelse buf "dup" streq if
            OpType.intrinsic Intrinsic.dup      lexer Lexer.Loc PushOp
        orelse buf "over" streq if
            OpType.intrinsic Intrinsic.over     lexer Lexer.Loc PushOp
        orelse buf "swap" streq if
            OpType.intrinsic Intrinsic.swap     lexer Lexer.Loc PushOp
        orelse buf "drop" streq if
            OpType.intrinsic Intrinsic.drop     lexer Lexer.Loc PushOp
        orelse buf "rot" streq if
            OpType.intrinsic Intrinsic.rot      lexer Lexer.Loc PushOp
        orelse buf "syscall0" streq if
            OpType.intrinsic Intrinsic.syscall0 lexer Lexer.Loc PushOp
        orelse buf "syscall1" streq if
            OpType.intrinsic Intrinsic.syscall1 lexer Lexer.Loc PushOp
        orelse buf "syscall2" streq if
            OpType.intrinsic Intrinsic.syscall2 lexer Lexer.Loc PushOp
        orelse buf "syscall3" streq if
            OpType.intrinsic Intrinsic.syscall3 lexer Lexer.Loc PushOp
        orelse buf "syscall4" streq if
            OpType.intrinsic Intrinsic.syscall4 lexer Lexer.Loc PushOp
        orelse buf "syscall5" streq if
            OpType.intrinsic Intrinsic.syscall5 lexer Lexer.Loc PushOp
        orelse buf "syscall6" streq if
            OpType.intrinsic Intrinsic.syscall6 lexer Lexer.Loc PushOp

        // -- INTEGER ---------------------
        orelse buf ParseInteger swap drop if
            OpType.push buf ParseInteger drop lexer Lexer.Loc PushOp
        else

            lexer Lexer.PrintLoc

            " ERROR: unknown word '" print
            buf print
            "'\n" print

            1 exit
        end
    end

    ParseBlockStackCount r64 0 != if
        "ERROR: unclosed block\n" eprint
        1 exit
    end

    fd r64 close drop
    contentLength r64 content r64 cast_ptr munmap drop
end

fun ReadArg int -- ptr ->
    8 * argv + r64 cast_ptr
end

fun main ->

    argc 2 < if
        "not enough arguments, expected filepath\n" eprint
        1 exit
    end

    1 ReadArg ParseFile
    GenerateAssembly
end

main

//PrintOps
