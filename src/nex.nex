include "std/std.nex"

const OpType.push 0 end
const OpType.intrinsic 1 end
const OpType.if 2 end
const OpType.else 3 end
const OpType.end 4 end

const Op 40 end // u64 u64 ptr u32 u32
fun Op.type     ptr -- ptr ->  0 + end // u64
fun Op.value    ptr -- ptr ->  8 + end // u64
fun Op.filepath ptr -- ptr -> 16 + end // ptr
fun Op.line     ptr -- ptr -> 24 + end // u64
fun Op.col      ptr -- ptr -> 32 + end // u64

const Intrinsic.plus   0 end
const Intrinsic.minus  1 end
const Intrinsic.mul    2 end
const Intrinsic.divmod 3 end
const Intrinsic.dump   4 end

const OP_CAP 1024 end
alloc OpBuf Op OP_CAP * end
alloc OpCount u64 end
0 OpCount s64

fun PushOp int int ptr int int ->
    OpCount r64 Op * OpBuf +
    dup Op.col      rot swap s64
    dup Op.line     rot swap s64
    dup Op.filepath rot swap s64
    dup Op.value    rot swap s64
    dup Op.type     rot swap s64
    drop
    OpCount inc64
end

fun PrintOps ->
    0 while dup OpCount r64 < do
        dup Op * OpBuf +
        over printd
        "->" print
        dup Op.filepath r64 cast_ptr print
        ":" print
        dup Op.line  r64 printd
        ":" print
        dup Op.col   r64 printd
        ": type: " print
        dup Op.type  r64 printd
        " data: " print
        dup Op.value r64 printd
        "\n" print
        drop

        1 +
    end drop
end

fun CmdEcho ptr ->
    alloc status u64 end
    alloc empty pointer end
    0 empty s64

    "[CMD]" print
    dup while dup r64 0 != do
        " " print
        // TODO escape the logged cmd
        dup r64 cast_ptr print
        8 +
    end drop
    "\n" print

    fork

    dup 0 = if
        drop
        dup r64 cast_ptr empty
        rot rot
        execve
        dup 0 < if
            "ERROR: could not execute external program\n" eprint
            1 exit
        end cast_ptr
    else 
        dup 0 > if
            drop
            NULL cast_ptr 0 status 0 1 - wait4 drop
        else
            drop
            "ERROR: could not fork a child\n" eprint
            1 exit
        end
    end

    drop
end

fun PrintLoc
    int // col
    int // line
    ptr // file
->
    print
    ":" print
    printd
    ":" print
    printd
    ":" print
end

fun GenerateAssembly ->
    alloc out u64 end
    
    420                            // mode
    O_CREAT O_WRONLY or O_TRUNC or // flags
    "output.asm"                   // path
    AT_FDCWD
    openat
    out s64

    out r64 0 < if
        "ERROR: could not open 'output.asm'\n" eprint
        1 exit
    end

    "segment .text\n"                           out r64 fprint
    "dump:\n"                                   out r64 fprint
    "    mov     r9, -3689348814741910323\n"    out r64 fprint
    "    sub     rsp, 40\n"                     out r64 fprint
    "    mov     BYTE [rsp+31], 10\n"           out r64 fprint
    "    lea     rcx, [rsp+30]\n"               out r64 fprint
    ".L2:\n"                                    out r64 fprint
    "    mov     rax, rdi\n"                    out r64 fprint
    "    lea     r8, [rsp+32]\n"                out r64 fprint
    "    mul     r9\n"                          out r64 fprint
    "    mov     rax, rdi\n"                    out r64 fprint
    "    sub     r8, rcx\n"                     out r64 fprint
    "    shr     rdx, 3\n"                      out r64 fprint
    "    lea     rsi, [rdx+rdx*4]\n"            out r64 fprint
    "    add     rsi, rsi\n"                    out r64 fprint
    "    sub     rax, rsi\n"                    out r64 fprint
    "    add     eax, 48\n"                     out r64 fprint
    "    mov     BYTE [rcx], al\n"              out r64 fprint
    "    mov     rax, rdi\n"                    out r64 fprint
    "    mov     rdi, rdx\n"                    out r64 fprint
    "    mov     rdx, rcx\n"                    out r64 fprint
    "    sub     rcx, 1\n"                      out r64 fprint
    "    cmp     rax, 9\n"                      out r64 fprint
    "    ja      .L2\n"                         out r64 fprint
    "    lea     rax, [rsp+32]\n"               out r64 fprint
    "    mov     edi, 1\n"                      out r64 fprint
    "    sub     rdx, rax\n"                    out r64 fprint
    "    xor     eax, eax\n"                    out r64 fprint
    "    lea     rsi, [rsp+32+rdx]\n"           out r64 fprint
    "    mov     rdx, r8\n"                     out r64 fprint
    "    mov     rax, 1\n"                      out r64 fprint
    "    syscall\n"                             out r64 fprint
    "    add     rsp, 40\n"                     out r64 fprint
    "    ret\n"                                 out r64 fprint
    "global _start\n"                           out r64 fprint
    "_start:\n"                                 out r64 fprint
    0 while dup OpCount r64 < do
        
        "addr_" out r64 fprint
        dup out r64 fprintd
        ":\n" out r64 fprint

        dup Op * OpBuf +

        dup Op.type r64 OpType.push = if
            "    mov rax, "                 out r64 fprint dup Op.value r64 out r64 fprintd "\n" out r64 fprint
            "    push rax\n"                out r64 fprint
        orelse dup Op.type r64 OpType.if = if
            "    pop rax\n"                 out r64 fprint
            "    test rax, rax\n"           out r64 fprint
            "    jz addr_"                  out r64 fprint dup Op.value r64 out r64 fprintd "\n" out r64 fprint
        orelse dup Op.type r64 OpType.else = if
            "    jmp addr_"                 out r64 fprint dup Op.value r64 out r64 fprintd "\n" out r64 fprint
        orelse dup Op.type r64 OpType.end = if
            over 1 + over Op.value r64 != if
                "    jmp addr_"                 out r64 fprint dup Op.value r64 out r64 fprintd "\n" out r64 fprint
            end
        orelse dup Op.type r64 OpType.intrinsic = if
            dup Op.value r64 Intrinsic.plus = if
                "    pop rax\n"                 out r64 fprint
                "    pop rbx\n"                 out r64 fprint
                "    add rax, rbx\n"            out r64 fprint
                "    push rax\n"                out r64 fprint
            orelse dup Op.value r64 Intrinsic.minus = if
                "    pop rax\n"                 out r64 fprint
                "    pop rbx\n"                 out r64 fprint
                "    sub rbx, rax\n"            out r64 fprint
                "    push rbx\n"                out r64 fprint
            orelse dup Op.value r64 Intrinsic.mul = if
                "    pop rax\n"                 out r64 fprint
                "    pop rbx\n"                 out r64 fprint
                "    mul rbx\n"                 out r64 fprint
                "    push rax\n"                out r64 fprint
            orelse dup Op.value r64 Intrinsic.divmod = if
                "    xor rdx, rdx\n"            out r64 fprint
                "    pop rbx\n"                 out r64 fprint
                "    pop rax\n"                 out r64 fprint
                "    div rbx\n"                 out r64 fprint
                "    push rax\n"                out r64 fprint
                "    push rdx\n"                out r64 fprint
            orelse dup Op.value r64 Intrinsic.dump = if
                "    pop rdi\n"                 out r64 fprint
                "    call dump\n"               out r64 fprint
            end
        end

        drop

        1 +
    end drop

    "addr_" out r64 fprint
    OpCount r64 out r64 fprintd
    ":\n" out r64 fprint

    "    mov rax, 60\n" out r64 fprint
    "    mov rdi, 0\n" out r64 fprint
    "    syscall\n" out r64 fprint

    alloc nasmArgv pointer 4 * end
    "/usr/bin/nasm"     nasmArgv 0 pointer * + s64
    "-felf64"           nasmArgv 1 pointer * + s64
    "output.asm"        nasmArgv 2 pointer * + s64
    0                   nasmArgv 3 pointer * + s64
    nasmArgv CmdEcho

    alloc ldArgv pointer 5 * end
    "/usr/bin/ld"       ldArgv 0 pointer * + s64
    "-o"                ldArgv 1 pointer * + s64
    "output"            ldArgv 2 pointer * + s64
    "output.o"          ldArgv 3 pointer * + s64
    NULL                ldArgv 4 pointer * + s64
    ldArgv CmdEcho

    alloc outputArgv pointer 2 * end
    "./output"          outputArgv 0 pointer * + s64
    NULL                outputArgv 1 pointer * + s64
    outputArgv CmdEcho
end

const PARSE_BLOCK_STACK_CAP 1024 end
alloc ParseBlockStack PARSE_BLOCK_STACK_CAP end
alloc ParseBlockStackCount u64 end
0 ParseBlockStack s64

fun ParseBlockStackPush int ->
    ParseBlockStackCount r64 PARSE_BLOCK_STACK_CAP >= if
        "ERROR: parse block stack overflow\n" eprint
        1 exit
    end

    ParseBlockStackCount r64 u64 * ParseBlockStack +
    s64
    ParseBlockStackCount inc64
end

fun ParseBlockStackPop -- int ->
    ParseBlockStackCount r64 0 <= if
        "ERROR: parse block stack underflow\n" eprint
        1 exit
    end

    ParseBlockStackCount dec64
    ParseBlockStackCount r64 u64 * ParseBlockStack +
    r64
end

fun CreateAndPushOp ptr ptr int int ->
    alloc file u64 end
    alloc line u64 end
    alloc col  u64 end
    col  s64
    line s64
    file s64

    dup "if" streq if
        OpCount r64 ParseBlockStackPush
        OpType.if 0 file r64 cast_ptr line r64 col r64 PushOp
    orelse dup "else" streq if
        ParseBlockStackCount r64 0 = if
            col r64
            line r64
            file r64 cast_ptr
            PrintLoc

            ": ERROR: 'else' can only be used in 'if' blocks\n" print

            1 exit
        end

        ParseBlockStackPop
        OpBuf over Op * +

        dup Op.type r64 OpType.if != if
            col r64
            line r64
            file r64 cast_ptr
            PrintLoc

            ": ERROR: 'else' can only be used in 'if' blocks\n" print

            1 exit
        end

        OpCount r64 1 + swap Op.value s64
        drop

        OpCount r64 ParseBlockStackPush

        OpType.else 0 file r64 cast_ptr line r64 col r64 PushOp
    orelse dup "end" streq if
        ParseBlockStackCount r64 0 = if
            col r64
            line r64
            file r64 cast_ptr
            PrintLoc

            ": ERROR: 'end' can only close 'if' and 'if-else' blocks\n" print

            1 exit
        end

        ParseBlockStackPop
        OpBuf over Op * +

        dup  Op.type r64 OpType.if   !=
        over Op.type r64 OpType.else != and if
            col r64
            line r64
            file r64 cast_ptr
            PrintLoc

            ": ERROR: 'end' can only close 'if' and 'if-else' blocks\n" print

            1 exit
        end

        OpCount r64 swap Op.value s64

        drop

        OpType.end OpCount r64 1 + file r64 cast_ptr line r64 col r64 PushOp
    orelse dup "+" streq if
        OpType.intrinsic Intrinsic.plus file r64 cast_ptr line r64 col r64 PushOp
    orelse dup "-" streq if
        OpType.intrinsic Intrinsic.minus file r64 cast_ptr line r64 col r64 PushOp
    orelse dup "*" streq if
        OpType.intrinsic Intrinsic.mul file r64 cast_ptr line r64 col r64 PushOp
    orelse dup "divmod" streq if
        OpType.intrinsic Intrinsic.divmod file r64 cast_ptr line r64 col r64 PushOp
    orelse dup "dump" streq if
        OpType.intrinsic Intrinsic.dump file r64 cast_ptr line r64 col r64 PushOp
    orelse dup ParseInteger swap drop if
        OpType.push over ParseInteger drop file r64 cast_ptr line r64 col r64 PushOp
    else
        col r64
        line r64
        file r64 cast_ptr
        PrintLoc

        " ERROR: unknown word '" print
        dup print
        "'\n" print

        1 exit
    end

    drop
end

fun ParseFile ptr ->
    alloc filepath string end
    filepath s64

    0
    O_RDONLY
    filepath r64 cast_ptr
    AT_FDCWD
    openat

    dup 0 < if
        "could not open file '" eprint filepath r64 cast_ptr eprint "'\n" eprint
        1 exit
    end

    alloc fd u64 end
    fd s64
    alloc statbuf stat end
    statbuf fd r64 fstat 0 < if
        "could not determine size of file '" eprint filepath r64 cast_ptr eprint "'\n" eprint
        1 exit
    end

    alloc content pointer end
    alloc contentLength u64 end
    statbuf stat.st_size r64 contentLength s64
    

    0                        // offset
    fd r64                   // fd
    MAP_PRIVATE              // flags
    PROT_READ                // prot
    contentLength r64        // length
    NULL cast_ptr            // addr
    mmap
    content s64

    content r64 0 < if
        "ERROR: could not map file " eprint filepath r64 cast_ptr eprint "'\n" eprint
        1 exit
    end

    alloc line u64 end
    alloc col u64 end
    alloc bufCol u64 end
    alloc buf 256 end
    alloc bufIdx u32 end

    alloc index u64 end
    
    1 line s64
    1 col s64
    1 bufCol s64
    0 index s64
    while content r64 cast_ptr index r64 + r8 0 != do
        
        content r64 cast_ptr index r64 + r8
        dup IsSpace if
            bufIdx r32 0 > if
                // buf is already null-terminated because of the previous 'memset'
                buf filepath r64 cast_ptr line r64 bufCol r64 CreateAndPushOp
                
                0 bufIdx s32
            end
        else
            bufIdx r32 0 = if
                col r64 bufCol s64
                0 buf 256 memset
            end

            dup
            buf bufIdx r32 +
            s8
            bufIdx inc32
        end

        10 = if
            line inc64
            1 col s64
        else
            col inc64
        end

        index inc64
    end

    bufIdx r32 0 > if
        buf filepath r64 cast_ptr line r64 bufCol r64 CreateAndPushOp
    end

    fd r64 close drop
    contentLength r64 content r64 cast_ptr munmap drop
end

fun ReadArg int -- ptr ->
    8 * argv + r64 cast_ptr
end

fun main ->

    argc 2 < if
        "not enough arguments, expected filepath\n" eprint
        1 exit
    end

    1 ReadArg ParseFile
    GenerateAssembly
end

main

//PrintOps